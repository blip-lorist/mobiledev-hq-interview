1. What does O(n) mean? O(n^2)? 
O(n) is the Big O notation that represents linear runtime growth. As the input size increases by n, the time complexity it takes to process the input also grows by n. When represented on a time / input-size graph, O(n) looks like a diagonal line rising from left to right. An example of an O(n) process might be a loop that prints each element in an input array. O(n^2) represents a more costly runtime than O(n), with a much steeper line on that time / input-size graph. This means that as your input grows, it will take n*n time. An example of O(n^2) in a program might be one loop nested in another loop, both processing all of your input. 

2. Describe the quick sort algorithm 
In my head, I think of this as "mostly quicksort" because the quickness will depend on the situation - you'll see in a bit that the starting input and how we handle pivots can impact the performance of this algorithm. Imagine giving an array of integers to the quicksort. Quicksort will choose a pivot element, then sort the array into two subarrays: The left subarray contains values that are less than the pivot value, and the right subarray contains values that are greater than the pivot value. Once the pivot is placed in between these subarrays, it is considered sorted, and then we move onto quicksorting the left and right subarrays. Since quicksort takes a "divide and conquer" approach by splitting your input into two subarrays, the best-case scenario would be if the pivot values are somewhere in the middle of the max and min input values, which might create an O(nlogn) situation. However, if your pivots are the largest or the smallest values in the array (like if the input's already been sorted), then you'd have a worse-case scenario of O(n^2). The algorithm would have to process each element as the pivot and compare all other elements to each pivot. Phew! 

3. In C, what is a pointer?
I just recently met pointers while reading The C Programming Language by Kernighan and Ritchie! A pointer lets you to store the memory address of one variable in another variable, so you can be super-precise with memory usage. (I imagine that this need arose back when memory resources were way more expensive and restricted.) Let's say I've got an integer-type variable named "unigoats", and I give it a value of 2. When I create a pointer, "ip" (short for "integer pointer), and point it at unigoats, then ip holds the same memory address that unigoats uses. If I increment the integer stored at ip (*ip +=1) and then print the unigoats value, then I will get 3. 

4. What is the difference between Stack and Heap memory?
Stack memory is a chunk of memory that is managed and organized in a fairly neat and tidy way that requires less human-management and attention. You call a function, variables get assigned and added to the stack, and when the function is done, the variables are automatically popped out of the stack memory, freeing up the memory. Stack memory is useful if you just need to store data and use it during a specific function. Heap memory is more high maintenance because the computer doesn't automatically clean things up for you. You're responsible for setting up the heap memory usage and then cleaning up once you're done with that memory. If you forget to free up some allocated memory, then it will result in an unintentional memory leak. Heap memory still has its advantages - you can store and access things globally in the heap, since data won't get cleaned up after functions run. 

5. What is the purpose of a garbage collector? 
A garbage collector is that convenient, automatic process your computer uses to clean up data and free up memory when it's (hopefully) not needed anymore.
